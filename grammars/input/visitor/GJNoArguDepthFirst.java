//
// Generated by JTB 1.3.2
//

package visitor;

import syntaxtree.*;
import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order. Your visitors may extend this class.
 */
public class GJNoArguDepthFirst implements GJNoArguVisitor<String> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public String visit(NodeList n) {
      String _ret = null;
      for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
         e.nextElement().accept(this);
      }
      return _ret;
   }

   public String visit(NodeListOptional n) {
      if (n.present()) {
         String _ret = null;
         for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
            e.nextElement().accept(this);
         }
         return _ret;
      } else
         return null;
   }

   public String visit(NodeOptional n) {
      if (n.present())
         return n.node.accept(this);
      else
         return null;
   }

   public String visit(NodeSequence n) {
      String _ret = null;
      for (Enumeration<Node> e = n.elements(); e.hasMoreElements();) {
         e.nextElement().accept(this);
      }
      return _ret;
   }

   public String visit(NodeToken n) {
      return null;
   }

   //
   // User-generated visitor methods below
   //

   // not needed functions

   void init() {
      typeTable.put("int", "int");
      typeTable.put("boolean", "boolean");
      typeTable.put("float", "float");
      typeTable.put("double", "double");
      typeTable.put("String", "String");
      typeTable.put("char", "char");
   }

   // needed functions

   void storeMethods(Node y, String className) {
      String methodName = ((MethodDeclaration) y).f2.f0.tokenImage;
      String returnType = ((MethodDeclaration) y).f1.f0.tokenImage;
      Vector<String> methodParamList = new Vector<String>();
      Vector<String> methodReturnType = new Vector<String>();
      NodeOptional k = ((MethodDeclaration) y).f4;
      if (k.present()) {
         FormalParameterList f = (FormalParameterList) k.node;
         String Type = f.f0.f0.accept(this);
         String varName = f.f0.f1.f0.tokenImage;
         methodParamList.add(varName);
         methodReturnType.add(Type);
         for (Node z : f.f1.nodes) {
            FormalParameterRest var = (FormalParameterRest) z;
            Type = var.f1.f0.accept(this);
            varName = var.f1.f1.f0.tokenImage;
            methodParamList.add(varName);
            methodReturnType.add(Type);
         }
      }
      methodInfo ml = new methodInfo(className + "_" + methodName, returnType, methodParamList,
            methodReturnType);
      mInfo.put(className + "_" + methodName, ml);
   }

   void declarationMethod(String tabsz, String varName, String varType) {
      symbolTable.put(varName, varType);
      methodTable.put(varName, -1);
      methodNameTable.put(varName, varName);
      if (typeTable.get(varType) == "Object" && check == false) {
         answers.add(tabsz + "Object x1;");
         answers.add(tabsz + "Object x2;");
         answers.add(tabsz + "Object " + varName + ";");
         answers.add(tabsz + "Object vtablePtr;");
         answers.add(tabsz + "String fnName;");
         check = true;
      } else if (typeTable.get(varType) == "Object") {
         answers.add(tabsz + "Object " + varName + ";");
      } else {
         answers.add(tabsz + varType + " " + varName + ";");
      }
   }

   void display() {
      for (String line : answers) {
         System.out.println(line);
      }
      return;
   }

   String getString(NodeToken... args) {
      String ans = "";
      for (NodeToken arg : args) {
         ans += arg.tokenImage + " ";
      }
      ans = ans.trim();
      return ans;
   }

   String getTabSize(Integer x) {
      spaces += x;
      String tabsz = "";
      for (int i = 0; i < spaces; i++) {
         tabsz += " ";
      }
      return tabsz;
   }

   class classInfo {
      String name;
      Vector<String> fields;
      Vector<String> methods;
      Vector<String> extensions;
      HashMap<String, Integer> fieldIndex; // this will have both className and methodName.
      HashMap<String, Integer> methodIndex; // this will have only the method's name and not the className.

      classInfo(String name, Vector<String> fields, Vector<String> methods, Vector<String> extensions,
            HashMap<String, Integer> methodIndex, HashMap<String, Integer> fieldIndex) {
         this.name = name;
         this.fields = fields;
         this.methods = methods;
         this.extensions = extensions;
         this.methodIndex = methodIndex;
         this.fieldIndex = fieldIndex;
      }
   }

   class methodInfo {
      String name;
      String returnType;
      Vector<String> paramList;
      Vector<String> paramType;

      methodInfo(String name, String returnType, Vector<String> paramList, Vector<String> paramType) {
         this.name = name;
         this.returnType = returnType;
         this.paramList = paramList;
         this.paramType = paramType;
      }
   }

   Vector<String> answers = new Vector<String>(); // to print lines in the main.java.
   HashMap<String, String> typeTable = new HashMap<>(); // type || className --> type
   HashMap<String, String> symbolTable = new HashMap<>(); // varName -> varType || className
   HashMap<String, Integer> methodTable = new HashMap<>(); // VarName -> -1 || idx
   HashMap<String, String> methodNameTable = new HashMap<>(); // VarName -> VarName || tempVarName
   HashMap<String, classInfo> clInfo = new HashMap<>(); // className -> classInfo
   HashMap<String, methodInfo> mInfo = new HashMap<>(); // className_methodName -> methodInfo
   Stack<String> classes = new Stack<>(); // gives the topmost class.
   Stack<String> methodCall = new Stack<>(); // gives the topmost method.

   Integer traversal = 0, spaces = 0;
   boolean check = false;

   // The main working starts below.
   /**
    * f0 -> MainClass()
    * f1 -> ( TypeDeclaration() )*
    * f2 -> <EOF>
    */
   public String visit(Goal n) {
      String _ret = null;
      MainClass mainClass = (MainClass) n.f0;
      String tabsz = getTabSize(0);
      answers.add(getString(mainClass.f0, mainClass.f1.f0) + mainClass.f2);
      answers.add(tabsz + "");
      answers.add(tabsz + "import static " + mainClass.f1.f0.tokenImage + ".memmgr.MemMgr.*;");
      answers.add(tabsz + "");
      answers.add(mainClass.f3.tokenImage + " Main {");
      answers.add(tabsz + "");
      tabsz = getTabSize(4);
      answers
            .add(tabsz + getString(mainClass.f6, mainClass.f7, mainClass.f8, mainClass.f9, mainClass.f10, mainClass.f11,
                  mainClass.f12) + getString(mainClass.f13, mainClass.f14.f0, mainClass.f15, mainClass.f16));
      answers.add(tabsz + "");

      // information gathering
      String className = mainClass.f4.f0.tokenImage, extendedClassName;
      Vector<String> methods = new Vector<String>();
      Vector<String> fields = new Vector<String>();
      Vector<String> extensions = new Vector<String>();
      HashMap<String, Integer> fieldIndex = new HashMap<String, Integer>();
      HashMap<String, Integer> methodIndex = new HashMap<String, Integer>();
      int mcounter = 0, fcounter = 0;
      methods.add(className + "_main");
      methodIndex.put("main", 0);
      classInfo cls = new classInfo(mainClass.f4.f0.tokenImage, methods, fields, extensions, methodIndex, fieldIndex);
      clInfo.put(className, cls);
      for (Node x : n.f1.nodes) {
         methods = new Vector<String>();
         fields = new Vector<String>();
         extensions = new Vector<String>();
         fieldIndex = new HashMap<String, Integer>();
         methodIndex = new HashMap<String, Integer>();
         mcounter = 0;
         fcounter = 0;

         // order of methodIndex --> methodName, return Type and then comes the variable
         // types.

         // another information.
         TypeDeclaration t = (TypeDeclaration) x;
         if (t.f0.which == 0) {
            ClassDeclaration c = ((ClassDeclaration) t.f0.choice);
            className = c.f1.f0.tokenImage;
            for (Node y : c.f4.nodes) {
               storeMethods(y, className);
               String methodName = ((MethodDeclaration) y).f2.f0.tokenImage;
               methods.add(className + "_" + methodName);
               methodIndex.put(methodName, mcounter++);
            }
            for (Node y : c.f3.nodes) {
               String fieldName = className + "_" + ((FieldDeclaration) y).f1.f0.tokenImage;
               fields.add(fieldName);
               fieldIndex.put(fieldName, fcounter++);
            }
            cls = new classInfo(className, fields, methods, extensions, methodIndex, fieldIndex);
            clInfo.put(className, cls);
         } else {
            ClassExtendsDeclaration c = ((ClassExtendsDeclaration) t.f0.choice);
            className = c.f1.f0.tokenImage;
            extendedClassName = c.f3.f0.tokenImage;
            classInfo pcls = clInfo.get(extendedClassName);
            for (String methodName : pcls.methods) {
               methods.add(methodName);
               methodIndex.put(methodName.substring(methodName.indexOf("_") + 1), mcounter++);
            }
            for (String fieldName : pcls.fields) {
               fields.add(fieldName);
               fieldIndex.put(fieldName, fcounter++);
            }
            for (String extension : pcls.extensions) {
               extensions.add(extension);
            }
            extensions.add(extendedClassName);
            for (Node y : c.f6.nodes) {
               storeMethods(y, className);
               String methodName = ((MethodDeclaration) y).f2.f0.tokenImage;
               if (pcls.methodIndex.containsKey(methodName)) {
                  int idx = pcls.methodIndex.get(methodName);
                  methods.set(idx, className + "_" + methodName);
               } else {
                  methods.add(className + "_" + methodName);
                  methodIndex.put(methodName, mcounter++);
               }
            }
            for (Node y : c.f5.nodes) {
               String fieldName = className + "_" + ((FieldDeclaration) y).f1.f0.tokenImage;
               fields.add(fieldName);
               fieldIndex.put(fieldName, fcounter++);
            }
            cls = new classInfo(className, fields, methods, extensions, methodIndex, fieldIndex);
            clInfo.put(className, cls);
         }
         typeTable.put(className, "Object");
      }

      // traversing the main class firstly.(variables)
      // boolean checker = false;
      Vector<String> temp = new Vector<String>();
      tabsz = getTabSize(4);
      for (Node x : mainClass.f17.nodes) {
         VarDeclaration var = ((VarDeclaration) x);
         String varType = var.f0.accept(this);
         String varName = var.f1.f0.tokenImage;
         temp.add(varName);
         declarationMethod(tabsz, varName, varType);
      }
      answers.add(tabsz + "");

      // calling the main function.
      classes.add(mainClass.f4.f0.tokenImage);
      n.f0.accept(this);
      for (String x : temp) {
         symbolTable.remove(x);
      }
      classes.pop();
      methodTable.clear();
      methodNameTable.clear();
      tabsz = getTabSize(-4);
      answers.add(tabsz + "}");
      answers.add("");
      n.f1.accept(this);
      n.f2.accept(this);
      answers.add("}");
      display();
      return _ret;
   }

   /**
    * f0 -> "package"
    * f1 -> Identifier()
    * f2 -> ";"
    * f3 -> "public class"
    * f4 -> Identifier()
    * f5 -> "{"
    * f6 -> "public"
    * f7 -> "static"
    * f8 -> "void"
    * f9 -> "main"
    * f10 -> "("
    * f11 -> "String"
    * f12 -> "["
    * f13 -> "]"
    * f14 -> Identifier()
    * f15 -> ")"
    * f16 -> "{"
    * f17 -> ( VarDeclaration() )*
    * f18 -> ( Statement() )*
    * f19 -> "}"
    * f20 -> "}"
    */
   public String visit(MainClass n) {
      String _ret = null;
      n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      n.f5.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      n.f8.accept(this);
      n.f9.accept(this);
      n.f10.accept(this);
      n.f11.accept(this);
      n.f12.accept(this);
      n.f13.accept(this);
      n.f14.accept(this);
      n.f15.accept(this);
      n.f16.accept(this);
      n.f17.accept(this);
      traversal = 0;
      check = false;
      n.f18.accept(this);
      traversal = 1;
      n.f18.accept(this);
      n.f19.accept(this);
      n.f20.accept(this);
      return _ret;
   }

   /**
    * f0 -> ClassDeclaration()
    * | ClassExtendsDeclaration()
    */
   public String visit(TypeDeclaration n) {
      spaces = 0;
      String _ret = null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "{"
    * f3 -> ( FieldDeclaration() )*
    * f4 -> ( MethodDeclaration() )*
    * f5 -> "}"
    */
   public String visit(ClassDeclaration n) {
      String _ret = null;
      classes.add(n.f1.f0.tokenImage);
      n.f0.accept(this);
      n.f2.accept(this);
      n.f4.accept(this);
      classes.pop();
      return _ret;
   }

   /**
    * f0 -> "class"
    * f1 -> Identifier()
    * f2 -> "extends"
    * f3 -> Identifier()
    * f4 -> "{"
    * f5 -> ( FieldDeclaration() )*
    * f6 -> ( MethodDeclaration() )*
    * f7 -> "}"
    */
   public String visit(ClassExtendsDeclaration n) {
      String _ret = null;
      classes.add(n.f1.f0.tokenImage);
      n.f0.accept(this);
      n.f2.accept(this);
      n.f4.accept(this);
      n.f6.accept(this);
      n.f7.accept(this);
      classes.pop();
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public String visit(VarDeclaration n) {
      String type = n.f0.accept(this);
      return type;
   }

   /**
    * f0 -> IntegerType()
    * f1 -> Identifier()
    * f2 -> ";"
    */
   public String visit(FieldDeclaration n) {
      String type = n.f0.accept(this);
      n.f1.accept(this);
      n.f2.accept(this);
      return type;
   }

   /**
    * f0 -> "public"
    * f1 -> IntegerType()
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( FormalParameterList() )?
    * f5 -> ")"
    * f6 -> "{"
    * f7 -> ( VarDeclaration() )*
    * f8 -> ( Statement() )*
    * f9 -> "return"
    * f10 -> SubPrimaryExpression()
    * f11 -> ";"
    * f12 -> "}"
    */
   public String visit(MethodDeclaration n) {
      String tabsz = getTabSize(4);
      String _ret = null;
      String className = classes.peek();
      methodInfo ml = mInfo.get(className + "_" + n.f2.f0.tokenImage);
      Integer sz = ml.paramList.size();
      String arguments = "";
      for (Integer i = 0; i < sz; i++) {
         if (typeTable.get(ml.paramType.get(i)) == "Object") {
            arguments += ",Object" + " " + ml.paramList.get(i);
         } else {
            arguments += "," + ml.paramType.get(i) + " " + ml.paramList.get(i);
         }
      }
      answers.add(
            tabsz + "public static " + n.f1.f0.tokenImage + " " + className + "_" + n.f2.f0.tokenImage + "(Object mthis"
                  + arguments + ") {");
      answers.add("");
      tabsz = getTabSize(4);
      methodCall.add(n.f2.f0.tokenImage);
      n.f0.accept(this);
      n.f1.accept(this);
      n.f3.accept(this);
      NodeOptional k = n.f4;
      Vector<String> temp = new Vector<String>();
      if (k.present()) {
         FormalParameterList f = (FormalParameterList) k.node;
         String varName = f.f0.f1.f0.tokenImage;
         String varType = f.f0.f0.accept(this);
         methodTable.put(varName, -1);
         methodNameTable.put(varName, varName);
         symbolTable.put(varName, varType);
         temp.add(varName);
         for (Node t : f.f1.nodes) {
            FormalParameterRest var = (FormalParameterRest) t;
            varName = var.f1.f1.f0.tokenImage;
            varType = var.f1.f0.accept(this);
            methodTable.put(varName, -1);
            methodNameTable.put(varName, varName);
            symbolTable.put(varName, varType);
            temp.add(varName);
         }
      }
      check = false;
      for (Node x : n.f7.nodes) {
         VarDeclaration var = (VarDeclaration) x;
         String varType = var.f0.accept(this);
         String varName = var.f1.f0.tokenImage;
         temp.add(varName);
         declarationMethod(tabsz, varName, varType);
      }
      answers.add("");
      traversal = 0;
      n.f8.accept(this);
      n.f9.accept(this);
      n.f10.accept(this);
      traversal = 1;
      n.f7.accept(this);
      if (!temp.isEmpty())
         answers.add("");
      n.f8.accept(this);
      String exp = n.f10.accept(this);
      answers.add(tabsz + "return " + exp + ";");
      methodTable.clear();
      methodNameTable.clear();
      methodCall.pop();
      for (String x : temp) {
         symbolTable.remove(x);
      }
      tabsz = getTabSize(-4);
      answers.add(tabsz + "}");
      answers.add("");
      tabsz = getTabSize(-4);
      return _ret;
   }

   /**
    * f0 -> FormalParameter()
    * f1 -> ( FormalParameterRest() )*
    */
   public String visit(FormalParameterList n) {
      String _ret = null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> Type()
    * f1 -> Identifier()
    */
   public String visit(FormalParameter n) {
      String type = n.f0.accept(this);
      n.f1.accept(this);
      return type;
   }

   /**
    * f0 -> ","
    * f1 -> FormalParameter()
    */
   public String visit(FormalParameterRest n) {
      String _ret = null;
      n.f0.accept(this);
      n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> BooleanType()
    * | IntegerType()
    * | StringType()
    * | Identifier()
    */
   public String visit(Type n) {
      String type = n.f0.accept(this);
      return type;
   }

   /**
    * f0 -> "boolean"
    */
   public String visit(BooleanType n) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "int"
    */
   public String visit(IntegerType n) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "String"
    */
   public String visit(StringType n) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> Block()
    * | AssignmentStatement()
    * | FieldAssignmentStatement()
    * | IfStatement()
    * | WhileStatement()
    * | PrintStatement()
    */
   public String visit(Statement n) {
      String _ret = null;
      n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> "{"
    * f1 -> ( Statement() )*
    * f2 -> "}"
    */
   public String visit(Block n) { // have to think about this.
      String tabsz = getTabSize(0);
      String _ret = null;
      if (traversal == 1) {
         answers.add(tabsz + "{");
      }
      tabsz = getTabSize(4);
      n.f1.accept(this);
      tabsz = getTabSize(-4);
      if (traversal == 1) {
         answers.add(tabsz + "}");
      }

      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "="
    * f2 -> Expression()
    * f3 -> ";"
    */

   // methodTable will always contain key.
   public String visit(AssignmentStatement n) {
      String identifier = n.f0.f0.tokenImage;
      n.f0.accept(this);
      String expression = n.f2.accept(this);
      String tabsz = getTabSize(0);
      String _ret = null;
      if (expression == "mthis") {
         methodNameTable.put(identifier, expression);
      } else if (expression != null && expression != "" && expression != "null") {
         if (traversal == 1) {
            if (methodTable.get(identifier) != -1) {
               String newidentifier = "t"+identifier; // added one line.
               answers.add(tabsz + newidentifier + " = " + expression + ";"); // added second line.
               answers.add(tabsz + "store(mthis," + (methodTable.get(identifier) + 1) * 4 + "," + newidentifier + ");"); // changed third line.
            } else {
               answers.add(tabsz + identifier + " = " + expression + ";");
            }
         }
      }
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "="
    * f4 -> Identifier()
    * f5 -> ";"
    */
   public String visit(FieldAssignmentStatement n) {
      String tabsz = getTabSize(0);
      String _ret = null;
      if (traversal == 1) {
         String className = symbolTable.get(n.f0.f0.tokenImage);
         String fieldName = className + "_" + n.f2.f0.tokenImage;
         String varName = n.f4.f0.tokenImage;
         classInfo cl = clInfo.get(className);
         Integer idx;
         if (cl.fieldIndex.containsKey(fieldName) == false) {
            for (Integer i = cl.extensions.size() - 1; i >= 0; i--) {
               fieldName = cl.extensions.get(i) + "_" + n.f2.f0.tokenImage;
               if (cl.fieldIndex.containsKey(fieldName) == true) {
                  break;
               }
            }
         }
         idx = cl.fieldIndex.get(fieldName);
         if (methodCall.empty()) {
            answers.add(tabsz + "store(" + n.f0.f0.tokenImage + "," + (idx + 1) * 4 + "," + varName + ");");
         } else {
            answers.add(tabsz + "store(mthis," + (idx + 1) * 4 + "," + varName + ");");
         }
      }
      if (traversal == 0) {
         n.f0.accept(this);
         n.f1.accept(this);
         n.f2.accept(this);
         n.f3.accept(this);
         n.f4.accept(this);
         n.f5.accept(this);
      }
      return _ret;

   }

   /**
    * f0 -> "if"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    * f5 -> "else"
    * f6 -> Statement()
    */
   public String visit(IfStatement n) {
      String tabsz = getTabSize(0);
      String _ret = null;
      n.f0.accept(this);
      n.f1.accept(this);
      String identifier = n.f2.accept(this);
      if (traversal == 1) {
         answers.add(tabsz + "if (" + identifier + ") ");
      }
      n.f4.accept(this);
      n.f5.accept(this);
      if (traversal == 1) {
         answers.add(tabsz + "else");
      }
      n.f6.accept(this);
      return _ret;
   }

   /**
    * f0 -> "while"
    * f1 -> "("
    * f2 -> Identifier()
    * f3 -> ")"
    * f4 -> Statement()
    */
   public String visit(WhileStatement n) {
      String tabsz = getTabSize(0);
      String _ret = null;
      n.f0.accept(this);
      n.f1.accept(this);
      String identifier = n.f2.accept(this);
      if (traversal == 1) {
         answers.add(tabsz + "while (" + identifier + ") ");
      }
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> "System.out.println"
    * f1 -> "("
    * f2 -> SubPrimaryExpression()
    * f3 -> ")"
    * f4 -> ";"
    */
   public String visit(PrintStatement n) {
      String tabsz = getTabSize(0);
      String _ret = null;
      n.f0.accept(this);
      String var = n.f2.accept(this);
      if (traversal == 1) {
         answers.add(tabsz + "System.out.println(" + var + ");");
         answers.add("");
      }
      n.f1.accept(this);
      n.f2.accept(this);
      n.f3.accept(this);
      n.f4.accept(this);
      return _ret;
   }

   /**
    * f0 -> OrExpression()
    * | AndExpression()
    * | CompareExpression()
    * | NeqExpression()
    * | PlusExpression()
    * | MinusExpression()
    * | TimesExpression()
    * | DivExpression()
    * | MessageSend()
    * | FieldReference()
    * | PrimaryExpression()
    */
   public String visit(Expression n) {
      String _ret = n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "&&"
    * f2 -> SubPrimaryExpression()
    */
   public String visit(AndExpression n) {
      String _ret = n.f0.accept(this) + "&&" + n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "||"
    * f2 -> SubPrimaryExpression()
    */
   public String visit(OrExpression n) {
      String _ret = n.f0.accept(this) + "||" + n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "<"
    * f2 -> SubPrimaryExpression()
    */
   public String visit(CompareExpression n) {
      String _ret = n.f0.accept(this) + "<" + n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "!="
    * f2 -> SubPrimaryExpression()
    */
   public String visit(NeqExpression n) {
      String _ret = n.f0.accept(this) + "!=" + n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "+"
    * f2 -> SubPrimaryExpression()
    */
   public String visit(PlusExpression n) {
      String _ret = n.f0.accept(this) + "+" + n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "-"
    * f2 -> SubPrimaryExpression()
    */
   public String visit(MinusExpression n) {
      String _ret = n.f0.accept(this) + "-" + n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "*"
    * f2 -> SubPrimaryExpression()
    */
   public String visit(TimesExpression n) {
      String _ret = n.f0.accept(this) + "*" + n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> "/"
    * f2 -> SubPrimaryExpression()
    */
   public String visit(DivExpression n) {
      String _ret = n.f0.accept(this) + "/" + n.f2.accept(this);
      return _ret;
   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    */
   public String visit(FieldReference n) {
      String tabsz = getTabSize(0);
      String className = symbolTable.get(n.f0.f0.tokenImage);
      String fieldName = className + "_" + n.f2.f0.tokenImage;
      classInfo cl = clInfo.get(className);
      Integer idx;
      if (cl.fieldIndex.containsKey(fieldName) == false) {
         for (Integer i = cl.extensions.size() - 1; i >= 0; i--) {
            fieldName = cl.extensions.get(i) + "_" + n.f2.f0.tokenImage;
            if (cl.fieldIndex.containsKey(fieldName) == true) {
               break;
            }
         }
      }
      idx = cl.fieldIndex.get(fieldName);
      if (traversal == 0) {
         if (methodTable.containsKey(fieldName) == false) {
            methodTable.put(fieldName, idx);
            methodNameTable.put(fieldName, "t" + fieldName);
            symbolTable.put(fieldName, className); // added extra line.
            answers.add(tabsz + "int " + methodNameTable.get(fieldName) + ";"); // TODO
         }
      } else if (traversal == 1) {
         if (methodCall.isEmpty()) {
            answers.add(tabsz + methodNameTable.get(fieldName) + " = (Integer) load(" + n.f0.f0.tokenImage + ","
                  + (idx + 1) * 4
                  + ");");
         } else {
            answers.add(tabsz + methodNameTable.get(fieldName) + " = (Integer) load(mthis," + (idx + 1) * 4 + ");");
         }
      }
      // n.f0.accept(this);
      // n.f1.accept(this);
      // n.f2.accept(this);
      return methodNameTable.get(fieldName);

   }

   /**
    * f0 -> Identifier()
    * f1 -> "."
    * f2 -> Identifier()
    * f3 -> "("
    * f4 -> ( ArgList() )?
    * f5 -> ")"
    */
   public String visit(MessageSend n) {
      String tabsz = getTabSize(0);
      String _ret = null;
      if (traversal == 1) {
         String varName = n.f0.f0.tokenImage;
         String className = symbolTable.get(varName);
         String methodName = n.f2.f0.tokenImage;
         answers.add(tabsz + "vtablePtr = load(" + methodNameTable.get(varName) + ",0);");
         classInfo cl = clInfo.get(className);
         Integer idx = cl.methodIndex.get(methodName);
         answers.add(tabsz + "fnName = (String) load(vtablePtr," + 4 * idx + ");");
         String arguments = n.f4.accept(this);
         if (arguments == null) {
            return "(Integer) callFunc(fnName," + methodNameTable.get(varName) + ")";
         }
         return "(Integer) callFunc(fnName," + methodNameTable.get(varName) + "," + arguments + ")";
      }
      return _ret;
   }

   /**
    * f0 -> SubPrimaryExpression()
    * f1 -> ( ArgRest() )*
    */
   public String visit(ArgList n) {
      String _ret = n.f0.accept(this);
      for (Node x : n.f1.nodes) {
         ArgRest ar = (ArgRest) x;
         if (ar.f1.f0.accept(this) != null) {
            _ret += "," + ar.f1.f0.accept(this);
         }
      }
      return _ret;
   }

   /**
    * f0 -> ","
    * f1 -> SubPrimaryExpression()
    */
   public String visit(ArgRest n) {
      String _ret = "," + n.f1.accept(this);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    * | TrueLiteral()
    * | FalseLiteral()
    * | Identifier()
    * | ThisExpression()
    * | AllocationExpression()
    * | NotExpression()
    */
   public String visit(PrimaryExpression n) {
      String _ret = n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> IntegerLiteral()
    * | TrueLiteral()
    * | FalseLiteral()
    * | Identifier()
    */
   public String visit(SubPrimaryExpression n) {
      String _ret = n.f0.accept(this);
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public String visit(IntegerLiteral n) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "true"
    */
   public String visit(TrueLiteral n) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> "false"
    */
   public String visit(FalseLiteral n) {
      return n.f0.tokenImage;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public String visit(Identifier n) {
      String tabsz = getTabSize(0);
      String identifier = n.f0.tokenImage;
      if (traversal == 0) {
         if (methodCall.isEmpty()) {
            // we are adding class variables --> do nothing.
         } else {
            if (methodTable.containsKey(identifier) == false) {
               String className = classes.peek();
               classInfo cl = clInfo.get(className);
               Integer idx = 0;
               if (cl.fieldIndex.containsKey(className + "_" + identifier)) {
                  idx = cl.fieldIndex.get(className + "_" + identifier);
               } else {
                  for (Integer i = cl.extensions.size() - 1; i >= 0; i--) {
                     if (cl.fieldIndex.containsKey(cl.extensions.get(i) + "_" + identifier)) {
                        idx = cl.fieldIndex.get(cl.extensions.get(i) + "_" + identifier);
                        break;
                     }
                  }
               }
               methodTable.put(identifier, idx);// to indicate temporary variable.
               methodNameTable.put(identifier, "t" + identifier);
               symbolTable.put(identifier, "int"); // to change here later on.
               answers.add(tabsz + "int " + methodNameTable.get(identifier) + ";"); // to change here later on.
            }
         }
      } else if (traversal == 1) {
         if (clInfo.containsKey(identifier) == true) {
            return identifier;
         }
         Integer idx = methodTable.get(identifier);
         if (idx != -1) {
            answers.add(tabsz
                  + methodNameTable.get(identifier) + " = (Integer) load(mthis," + (idx + 1) * 4 + ");");
         }
      }
      if (methodTable.containsKey(identifier))
         return methodNameTable.get(identifier);
      return identifier;
   }

   /**
    * f0 -> "this"
    */
   public String visit(ThisExpression n) {
      String tabsz = getTabSize(0);
      if (check == false) {
         answers.add(tabsz + "Object vTablePtr;");
         answers.add(tabsz + "String fnName;");
         check = true;
      }
      return "mthis";
   }

   /**
    * f0 -> "new"
    * f1 -> Identifier()
    * f2 -> "("
    * f3 -> ")"
    */
   public String visit(AllocationExpression n) {
      if (traversal == 1) {
         String tabsz = getTabSize(0);
         String className = n.f1.f0.tokenImage;
         classInfo cl = clInfo.get(className);
         Integer s1 = (cl.fields.size() + 1) * 4;
         Integer s2 = (cl.methods.size()) * 4;

         answers.add(tabsz + "x1 = alloc(" + s1.toString() + ");");
         for (Integer i = 4; i < s1; i += 4) {
            answers.add(tabsz + "store(x1," + i.toString() + ",0);");
         }
         answers.add(tabsz + "");

         answers.add(tabsz + "x2 = alloc(" + s2.toString() + ");");
         for (Integer i = 0; i < s2; i += 4) {
            String methodName = cl.methods.get(i / 4);
            answers.add(tabsz + "store(x2," + i.toString() + ",\"" + methodName + "\");");
         }
         answers.add(tabsz + "");

         answers.add(tabsz + "store(x1,0,x2);");
         return "x1";
      }
      return null;
   }

   /**
    * f0 -> "!"
    * f1 -> Identifier()
    */
   public String visit(NotExpression n) {
      n.f0.accept(this);
      String identifier = n.f1.accept(this);
      return "!" + identifier;
   }

}
